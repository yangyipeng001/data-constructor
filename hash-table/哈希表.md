# 哈希表

## 哈希表通常是基于数组进行实现的，但是相对于数组，他也有很多优势
- 它可以提供非常快速的***插入-删除-查找操作***。
- 无论多少数据，插入和删除值需要接近常量的时间：即O(1)的时间级。实际上，只需要***几个机器指令***即可完成。
- 哈希表的速度比***树还要快***，基本可以瞬间查找到想要的元素。
- 哈希表相对于树来说，编码要容易很多。


## 哈希表相对于数组的劣势
- 哈希表中的数据是***没有顺序***的，所以不能以一种固定的方式（比如从小到大）来遍历其中的元素。
- 通常情况下，哈希表中的key是***不允许重复的***,不能放置相同的key,用于保存不同的元素。


## 哈希表是什么？
他的结构是数组，但是他神奇的地方在于对***下标值的一种转换***，这种变换我们称之为***哈希函数***，通过哈希函数可以获取到***HashCode***。


## 哈希表的一些概念
- 哈希化：将***大数字***转化成***数组范围内的下标***的过程，我们就称之为***哈希化***。
- 哈希函数：通常我们会将***单词***转成***大数字，大数字***在进行***哈希化***的代码实现放在一个函数中，这个函数我们称为***哈希函数***。
- 哈希表：最终将数据插入到这个***数组***，对整个***结构的封装***，我们就称之为是一个***哈希表***。


## 解决冲突
### 链地址法（拉链法）
- 在重复的位置改为数组或链表存储。

### 开放地址法
工作方式是***寻找空白的单元格***来添加重复的数据。

#### 寻找空白的地址有三种方法：
##### 线性探测：线性的查找空白的单元。
- 查询到***空位置，就停止。*** 
- 删除操作一个数据项时，***不可以***将这个位置下标的内容***设置为null***。
- 因为将它设置为null可能会***影响我们之后查询其他操作***，所以通常***删除一个位置的数据项***时，我们可以***将它进行特殊处理***（比如设置为-1）。
- 当我们之后看到-1位置的数据项时，就知道查询时要***继续查询***，但是插入时这个位置可以放置数据。

##### 缺点
- 线性探测有一个比较严重的问题，就是聚集。
- 比如我们在没有任何数据时，插入的是22-23-24-25-26，那么意味着下标2-3-4-5-6位置都有元素。
- 这种***一连串填充单元***就叫做***聚集***。
- 聚集会影响哈希表的***性能***，无论是插入/查询/删除都会有影响。
- 比如我们插入一个32，会发现***连续的单元都不允许***我们放置数据，并且在这个过程我们需要探索多次。
- 二次探测可以解决一部分这个问题。

#### 二次探测
##### 二次探测在线性探测的基础上进行了优化
- 二次探测主要优化的是***探测时的步长。***
- 线性探测我们看成步长为1的探测，比如下标值x开始，那么线性探测就是x+1，x+2，x+3依次探测。
- 二次探测对步长做了优化，比如下标值x开始，x+1^2，x+2^2，x+3^2。
- 这样就可以***一次性测探比较长的距离***，避免那些聚集带来的影响。

##### 缺点
- 二次探测依然存在问题，比如我们连续插入的是32-112-82-2-192，那么它们依次累加的时候步长是相同的。
- 也就是这种情况下会造成***步长不一的一种聚集***，还是会影响效率。（当然这种可能相对于***连续的数字***会小一些）
- ***再哈希法***来解决每一个步长不一样。

#### 再哈希法
##### 特点
- 二次探测的算法产生的探测序列步长是固定的：1，4，9，16，依次类推。
- 现在需要一种方法：产生一种***依赖关键字的探测序列***，而不是每个关键字都一样。
- ***不同的关键字***即使映射到***相同的数组下标***，也可以使用***不同的探测序列***。
- 再哈希法的做法就是：把关键字用另一个哈希函数，***再做一次哈希化***，用这次哈希化的***结果作为步长***。
- 对于***指定的关键字***，***步长***在整个探测过程中是***不变***的，不过***不同的关键字***，使用***不同的步长***。

##### 第二次哈希化需要具备以下特点
- 和***第一个哈希函数不同***。（不要再使用上一次的哈希函数了，不然结果还是原来的位置）
- ***不能输出为0***（否则将没有步长，每次探测都是原地踏步，算法就进入了死循环）。

##### 计算机专家已经设计出一种工作很好的哈希函数
- stepSize = constant - (key % constant)
- 其中constant是质数，且小于数组的容量。
- 例如：stepSize = 5 - (key % 5)，满足需求，并且结果不可能为0。


## 哈希化的效率
### 哈希表中执行插入和搜索操作的效率是非常高的。
- 如果***没有产生冲突***，那么效率就会更高。
- 如果***发生冲突***，存取时间就依赖于后来的探测长度。
- 平均探测长度以及平均存取时间，取决于***填装因子***，随着填装因子变大，探测长度也越来越长。
- 随着填装因子变大，效率下降的情况，在不同开放地址法方案中比链地址法更严重，所以我们来对比一下它们的效率，再决定我们选取的方案。

### 填装因子
- 填装因子表示当前哈希表中已经***包含的数据项***和***整个哈希表的长度**的***比值***。
- ***填装因子 = 总数据项 / 哈希表长度***。
- ***开放地址法的填装因子***最大的长度呢？1， 因为它必须寻找到空白的单元才能将元素放入。
- ***链地址法的填装因子***呢？可以大于1，因为链地址法可以无限的延伸下去，只要你愿意。（当然后面的效率就变低了）


## 优秀的哈希函数
### 哈希函数提高效率
- 哈希表的主要***优点是它的速度***，所以速度上不能满足，那么就达不到设计的目的。
- 提高速度的方法就是哈希函数***尽量少的有乘法和除法***，因为他们的性能比较低。

### 优点
- 快速的计算
    - 哈希表的优势就在于效率，所以快速获取到对应的hashCode非常重要。
    - 我们需要通过快速的计算来获取到元素对应的hashCode。

- 均匀的分布
    - 哈希表中，无论是链地址法还是开放地址发，当多个元素映射到同一个位置的时候，会影响到效率。
    - 优秀的哈希函数应该尽可能将元素映射到不同的位置，让元素在哈希表均匀的分布。

### 快速计算：霍纳法则（中国：秦九韶算法）
```js
// 霍纳将多项式进行变形：
P(x) = a3x3 + a3x2 + a1x + a0 → P(x) = x ( x ( x ( a3 ) + a2 ) + a1 ) + a0 
```

